<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>CYBER COURIER 2049</title>

<style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
}

body {
    background: #0a0a1a;
    color: white;
    font-family: Courier New, monospace;
    overflow: hidden;
}

#gameContainer {
    width: 100vw;
    height: 100vh;
}

#startScreen {
    position: fixed;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: radial-gradient(#001, #000);
    z-index: 10;
}

h1 {
    color: #00ffea;
    text-shadow: 0 0 20px #00ffea;
    margin-bottom: 10px;
}

button {
    margin-top: 25px;
    padding: 15px 40px;
    font-size: 20px;
    border-radius: 30px;
    border: none;
    cursor: pointer;
    background: linear-gradient(45deg, #ff00ff, #00ffea);
    color: white;
    box-shadow: 0 0 30px #ff00ff;
}
</style>

<script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
</head>

<body>

<div id="startScreen">
    <h1>CYBER COURIER 2049</h1>
    <p>Доставляй данные. Выживай.</p>
    <button onclick="startGame()">START RUN</button>
</div>

<div id="gameContainer"></div>

<script>
/* ================= TELEGRAM ================= */
let tg = null;
try {
    tg = window.Telegram.WebApp;
    tg.ready();
    tg.expand();
} catch (e) {
    console.log("Без Telegram");
}

/* ================= GAME STATE ================= */
const STATE = {
    distance: 0,
    lives: 3,
    speed: 1
};

/* ================= PHASER SCENE ================= */
class MainScene extends Phaser.Scene {
    constructor() {
        super('MainScene');
    }

    preload() {
        const g = this.make.graphics({ x: 0, y: 0, add: false });

        g.fillStyle(0x00ffea);
        g.fillRect(0, 0, 40, 60);
        g.generateTexture('player', 40, 60);

        g.clear();
        g.fillStyle(0xff3366);
        g.fillRect(0, 0, 50, 80);
        g.generateTexture('obstacle', 50, 80);

        g.clear();
        g.fillStyle(0x00ffea);
        g.fillCircle(15, 15, 15);
        g.generateTexture('data', 30, 30);

        g.destroy();
    }

    create() {
        this.physics.world.gravity.y = 900;

        this.ground = this.add.rectangle(180, 600, 360, 80, 0x003344);
        this.physics.add.existing(this.ground, true);

        this.player = this.physics.add.sprite(80, 480, 'player');
        this.player.setCollideWorldBounds(true);

        this.obstacles = this.physics.add.group();
        this.dataItems = this.physics.add.group();

        this.physics.add.collider(this.player, this.ground);
        this.physics.add.overlap(this.player, this.obstacles, this.hitObstacle, null, this);
        this.physics.add.overlap(this.player, this.dataItems, this.collectData, null, this);

        this.input.on('pointerdown', () => {
            if (this.player.body.touching.down) {
                this.player.setVelocityY(-420);
            }
        });

        this.distanceText = this.add.text(10, 10, '0 m', { fontSize: '20px', fill: '#00ffea' });
        this.livesText = this.add.text(10, 40, '❤️ 3', { fontSize: '20px', fill: '#ff3366' });

        this.time.addEvent({
            delay: 1200,
            loop: true,
            callback: () => this.spawnObstacle()
        });

        this.time.addEvent({
            delay: 800,
            loop: true,
            callback: () => this.spawnData()
        });
    }

    update() {
        STATE.distance += STATE.speed;
        this.distanceText.setText(STATE.distance + ' m');

        this.obstacles.getChildren().forEach(o => {
            o.x -= 4 * STATE.speed;
            if (o.x < -50) o.destroy();
        });

        this.dataItems.getChildren().forEach(d => {
            d.x -= 3 * STATE.speed;
            if (d.x < -50) d.destroy();
        });
    }

    spawnObstacle() {
        const o = this.obstacles.create(400, 500, 'obstacle');
        o.body.allowGravity = false;
    }

    spawnData() {
        if (Math.random() > 0.7) {
            const d = this.dataItems.create(400, Phaser.Math.Between(200, 450), 'data');
            d.body.allowGravity = false;
        }
    }

    hitObstacle() {
        STATE.lives--;
        this.livesText.setText('❤️ ' + STATE.lives);

        if (STATE.lives <= 0) {
            this.scene.restart();
            STATE.lives = 3;
            STATE.distance = 0;
        }
    }

    collectData(player, data) {
        data.destroy();
        STATE.speed += 0.05;
    }
}

/* ================= GAME CONFIG ================= */
const gameConfig = {
    type: Phaser.AUTO,
    width: 360,
    height: 640,
    parent: 'gameContainer',
    physics: {
        default: 'arcade'
    },
    scene: MainScene,
    scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH
    },
    backgroundColor: '#0a0a1a'
};

let game = null;

/* ================= START ================= */
function startGame() {
    document.getElementById('startScreen').style.display = 'none';

    if (!game) {
        game = new Phaser.Game(gameConfig);
    } else {
        game.scene.start('MainScene');
    }
}
</script>

</body>
</html>
